Implementation:

Setting up openrave:

Install Ubuntu 14.04 on your system. You can do this on a virtual machine but installing natively will be easier and openrave will run faster. Do not use a different version of linux!
We will be using openrave 0.9, which does not have packages you can install, so you will need to compile it from source.  Follow the instructions at http://openrave.org/docs/latest_stable/coreapihtml/installation_linux.html, but instead of the Install Dependencies step (which doesn’t work for this version of Ubuntu), do

$ sudo apt-get install libsoqt4-dev libsoqt-dev-common libopenscenegraph-dev liblapack-dev libpcre++-dev libode-dev libbullet-dev libboost-all-dev libxml2-dev collada-dom2.4-dp*

After openrave is installed, you can find examples showing how to use the python interface to command openrave in this directory: /usr/local/lib/python2.7/dist-packages/openravepy/_openravepy_0_9/examples
Go to the above directory and run the following command:

python simplemanipulation.py

You should see the PR2 robot in an environment with a doorway in the openrave viewer. The command line should tell you that the robot will navigate to a target. After a few seconds the robot may drive to a goal on the other side of the doorway or not (depending on if the planner succeeded). If you do not see the robot in the environment, openrave has not installed correctly. You may see some warnings in the terminal like :
[kinbody.cpp:1481 SetDOFValues] dof 32 value is not in limits 0.000000e+00<-1.000000e-01”
You can ignore these.

Be aware that openrave may not clean up its graphics structures correctly on all systems. This can result in errors being displayed after you close openrave. These can be ignored.
Important Principles in Openrave:
        Locking the environment: You can grab the lock on the environment data structure (what is displayed in the viewer) using the “with env:” statement (where env is an instance of the Environment class). See the simplmanipulation.py example to see how to use this. It is important to use this lock so that other openrave threads don’t interrupt what you’re doing and change variables you may be working on. Keep in mind that as long as you are inside a “with env:” block, changes you make to the robot (e.g. setting the configuration) may not be visible on the display. It is only after you exit this block and wait some amount of time that the display has the chance to refresh and show what you modified. However, the changes you make inside “with env:” still take place in the data structure. For instance, you can check a collision inside a “with env:” block by setting the configuration and calling check collision. Although you don’t see the display update, the robot is actually at the new configuration and the collision check is taking this into account. After you exit the “with env:” block and wait, you will see the robot rendered at the new configuration.
        Active DOFs: A robot can have many degrees of freedom (e.g. a humanoid), but you may not want to plan for all of those DOF at the same time. For instance, you may want to drive the mobile base of a robot but not move that robot’s arms. In openrave, you can select which DOF you want to plan for by using robot.SetActiveDOFs(...) (you can look up this function to see how it works). From then on, you can robot.SetActiveDOFValues(...) to set only the DOFs of the robot you care about. For example, robot.SetActiveDOFs([0,5,6]) will set the 0th, 5th, and 6th DOFs to be active. Then you can do robot.SetActiveDOFValues([pi/2,pi,0]) which will set the 0th joint to pi/2 radians, the 5th joint to pi radians, and 6th joint to 0 radians.
        Controllers: In openrave you often set a configuration for the robot to test something about it. For instance, you set a configuration and then test if it is in collision. However, you don’t always want the robot to go there (remember that openrave can directly control a real robot). So, to test things out we can use commands such as robot.SetActiveDOFValues(...) to set a configuration for the robot for testing something out. If we really want the robot to go there, we have to tell that to the robot’s controller. For instance, robot.GetController().SetDesired(robot.GetDOFValues()) will tell the robot to go whatever configuration is set on it (in simulation the robot moves to this configuration instantly, on the real robot this of course takes time). It is important to note that the controller runs in a different thread from your main code (this is so you can do things while the robot is moving). Thus, if you want to move the robot somewhere, after you tell the controller where to go, you need to wait until the controller is done. This can be done by polling this function: robot.GetController().IsDone(). The display in openrave renders whatever configuration the controller is currently at. Note that when you execute a planned path, you also need to use the robot’s controller and so you need to wait for that to complete by polling the same function.
        Viewer: The openrave viewer comes with some handy functionality to allow you to zoom in and out and focus on different parts of the scene.  To zoom in/out use the scroll wheel on your mouse. To focus on a part of the scene, click on the viewer window and then push ‘s’. Then click on the part of the scene you want to focus on. You can rotate around that point by holding down the left mouse button and dragging the mouse. You can translate the camera by holding down the scroll wheel and moving the mouse.
